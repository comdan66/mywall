{
version: 3,
file: "ZeroClipboard.min.js",
sources: [
"ZeroClipboard.js"
],
names: [
"window",
"undefined",
"_currentElement",
"_copyTarget",
"_window",
"_document",
"document",
"_navigator",
"navigator",
"_setTimeout",
"setTimeout",
"_encodeURIComponent",
"encodeURIComponent",
"_ActiveXObject",
"ActiveXObject",
"_Error",
"Error",
"_parseInt",
"Number",
"parseInt",
"_parseFloat",
"parseFloat",
"_isNaN",
"isNaN",
"_round",
"Math",
"round",
"_now",
"Date",
"now",
"_keys",
"Object",
"keys",
"_defineProperty",
"defineProperty",
"_hasOwn",
"prototype",
"hasOwnProperty",
"_slice",
"Array",
"slice",
"_unwrap",
"unwrapper",
"el",
"wrap",
"unwrap",
"div",
"createElement",
"unwrappedDiv",
"nodeType",
"e",
"_args",
"argumentsObj",
"call",
"_extend",
"i",
"len",
"arg",
"prop",
"src",
"copy",
"args",
"arguments",
"target",
"length",
"_deepCopy",
"source",
"_pick",
"obj",
"newObj",
"_omit",
"indexOf",
"_deleteOwnProperties",
"_containedBy",
"ancestorEl",
"ownerDocument",
"parentNode",
"_getDirPathOfUrl",
"url",
"dir",
"split",
"lastIndexOf",
"_getCurrentScriptUrlFromErrorStack",
"stack",
"matches",
"match",
"_getCurrentScriptUrlFromError",
"err",
"sourceURL",
"fileName",
"_getCurrentScriptUrl",
"jsPath",
"scripts",
"currentScript",
"getElementsByTagName",
"readyState",
"_getUnanimousScriptParentDir",
"jsDir",
"_getDefaultSwfPath",
"_flashState",
"bridge",
"version",
"pluginType",
"disabled",
"outdated",
"unavailable",
"deactivated",
"overdue",
"ready",
"_minimumFlashVersion",
"_handlers",
"_clipData",
"_clipDataFormatMap",
"_eventMessages",
"error",
"flash-disabled",
"flash-outdated",
"flash-unavailable",
"flash-deactivated",
"flash-overdue",
"_globalConfig",
"swfPath",
"trustedDomains",
"location",
"host",
"cacheBust",
"forceEnhancedClipboard",
"flashLoadTimeout",
"autoActivate",
"bubbleEvents",
"containerId",
"containerClass",
"swfObjectId",
"hoverClass",
"activeClass",
"forceHandCursor",
"title",
"zIndex",
"_config",
"options",
"test",
"_isValidHtml4Id",
"_state",
"browser",
"flash",
"zeroclipboard",
"ZeroClipboard",
"config",
"_isFlashUnusable",
"_on",
"eventType",
"listener",
"events",
"added",
"toLowerCase",
"on",
"replace",
"push",
"emit",
"type",
"errorTypes",
"name",
"_off",
"foundIndex",
"perEventHandlers",
"off",
"splice",
"_listeners",
"_emit",
"event",
"eventCopy",
"returnVal",
"tmp",
"_createEvent",
"_preprocessEvent",
"_dispatchCallbacks",
"this",
"_mapClipDataToFlash",
"data",
"formatMap",
"_create",
"isFlashUnusable",
"maxWait",
"_embedSwf",
"_destroy",
"clearData",
"blur",
"_unembedSwf",
"_setData",
"format",
"dataObj",
"dataFormat",
"_clearData",
"_getData",
"_focus",
"element",
"_removeClass",
"_addClass",
"newTitle",
"getAttribute",
"htmlBridge",
"_getHtmlBridge",
"setAttribute",
"useHandCursor",
"_getStyle",
"_setHandCursor",
"_reposition",
"_blur",
"removeAttribute",
"style",
"left",
"top",
"width",
"_activeElement",
"id",
"relatedTarget",
"currentTarget",
"timeStamp",
"msg",
"message",
"minimumVersion",
"clipboardData",
"setData",
"_mapClipResultsFromFlash",
"_getRelatedTarget",
"_addMouseData",
"targetEl",
"relatedTargetId",
"getElementById",
"srcElement",
"fromElement",
"toElement",
"pos",
"_getDOMObjectPosition",
"screenLeft",
"screenX",
"screenTop",
"screenY",
"scrollLeft",
"body",
"documentElement",
"scrollTop",
"pageX",
"_stageX",
"pageY",
"_stageY",
"clientX",
"clientY",
"moveX",
"movementX",
"moveY",
"movementY",
"x",
"y",
"offsetX",
"offsetY",
"layerX",
"layerY",
"_shouldPerformAsync",
"_dispatchCallback",
"func",
"context",
"async",
"apply",
"wildcardTypeHandlers",
"specificTypeHandlers",
"handlers",
"concat",
"originalContext",
"handleEvent",
"sourceIsSwf",
"_source",
"flashErrorNames",
"wasDeactivated",
"textContent",
"htmlContent",
"value",
"outerHTML",
"innerHTML",
"innerText",
"_safeActiveElement",
"focus",
"_fireMouseEvent",
"bubbles",
"cancelable",
"doc",
"defaults",
"view",
"defaultView",
"canBubble",
"detail",
"button",
"which",
"createEvent",
"dispatchEvent",
"ctrlKey",
"altKey",
"shiftKey",
"metaKey",
"initMouseEvent",
"_createHtmlBridge",
"container",
"className",
"position",
"height",
"_getSafeZIndex",
"flashBridge",
"nodeName",
"allowScriptAccess",
"_determineScriptAccess",
"allowNetworking",
"flashvars",
"_vars",
"swfUrl",
"_cacheBust",
"divToBeReplaced",
"appendChild",
"tmpDiv",
"oldIE",
"firstChild",
"replaceChild",
"display",
"removeSwfFromIE",
"removeChild",
"clipData",
"newClipData",
"text",
"html",
"rtf",
"clipResults",
"newResults",
"tmpHash",
"path",
"domain",
"domains",
"str",
"trustedOriginsExpanded",
"_extractDomain",
"protocol",
"join",
"originOrUrl",
"protocolIndex",
"pathIndex",
"_extractAllDomains",
"origins",
"resultsArray",
"currentDomain",
"configOptions",
"swfDomain",
"activeElement",
"classList",
"contains",
"add",
"classNames",
"setClass",
"c",
"cl",
"remove",
"getComputedStyle",
"getPropertyValue",
"_getZoomFactor",
"rect",
"physicalWidth",
"logicalWidth",
"zoomFactor",
"getBoundingClientRect",
"right",
"offsetWidth",
"info",
"pageXOffset",
"pageYOffset",
"leftBorderWidth",
"clientLeft",
"topBorderWidth",
"clientTop",
"bottom",
"enabled",
"setHandCursor",
"val",
"_detectFlashSupport",
"parseFlashVersion",
"desc",
"isPepperFlash",
"flashPlayerFileName",
"inspectPlugin",
"plugin",
"hasFlash",
"flashVersion",
"description",
"filename",
"isPPAPI",
"ax",
"mimeType",
"isActiveX",
"plugins",
"mimeTypes",
"enabledPlugin",
"GetVariable",
"e1",
"e2",
"e3",
"_createClient",
"writable",
"configurable",
"enumerable",
"state",
"create",
"destroy",
"getData",
"activate",
"deactivate",
"_clientIdCounter",
"_clientMeta",
"_elementIdCounter",
"_elementMeta",
"_mouseHandlers",
"_clientConstructor",
"elements",
"client",
"instance",
"clip",
"_clientOn",
"_clientOff",
"_clientListeners",
"_clientEmit",
"_clientShouldEmit",
"_clientDispatchCallbacks",
"_clientClip",
"_prepClip",
"zcClippingId",
"_addMouseHandlers",
"clippedElements",
"_clientUnclip",
"meta",
"arrayIndex",
"clientIds",
"_removeMouseHandlers",
"_clientElements",
"_clientDestroy",
"unclip",
"clippedEls",
"hasClippedEls",
"goodTarget",
"goodRelTarget",
"goodClient",
"_suppressMouseEvents",
"stopImmediatePropagation",
"preventDefault",
"_elementMouseOver",
"addEventListener",
"mouseover",
"mouseout",
"mouseenter",
"mouseleave",
"mousemove",
"mouseHandlers",
"key",
"mouseEvents",
"removeEventListener",
"setText",
"setHtml",
"setRichText",
"richText",
"define",
"amd",
"module",
"exports"
],
mappings: "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",
sourcesContent: [
"/*! * ZeroClipboard * The ZeroClipboard library provides an easy way to copy text to the clipboard using an invisible Adobe Flash movie and a JavaScript interface. * Copyright (c) 2014 Jon Rohan, James M. Greene * Licensed MIT * http://zeroclipboard.org/ * v2.1.6 */ (function(window, undefined) { "use strict"; /** * Store references to critically important global functions that may be * overridden on certain web pages. */ var _window = window, _document = _window.document, _navigator = _window.navigator, _setTimeout = _window.setTimeout, _encodeURIComponent = _window.encodeURIComponent, _ActiveXObject = _window.ActiveXObject, _Error = _window.Error, _parseInt = _window.Number.parseInt || _window.parseInt, _parseFloat = _window.Number.parseFloat || _window.parseFloat, _isNaN = _window.Number.isNaN || _window.isNaN, _round = _window.Math.round, _now = _window.Date.now, _keys = _window.Object.keys, _defineProperty = _window.Object.defineProperty, _hasOwn = _window.Object.prototype.hasOwnProperty, _slice = _window.Array.prototype.slice, _unwrap = function() { var unwrapper = function(el) { return el; }; if (typeof _window.wrap === "function" && typeof _window.unwrap === "function") { try { var div = _document.createElement("div"); var unwrappedDiv = _window.unwrap(div); if (div.nodeType === 1 && unwrappedDiv && unwrappedDiv.nodeType === 1) { unwrapper = _window.unwrap; } } catch (e) {} } return unwrapper; }(); /** * Convert an `arguments` object into an Array. * * @returns The arguments as an Array * @private */ var _args = function(argumentsObj) { return _slice.call(argumentsObj, 0); }; /** * Shallow-copy the owned, enumerable properties of one object over to another, similar to jQuery's `$.extend`. * * @returns The target object, augmented * @private */ var _extend = function() { var i, len, arg, prop, src, copy, args = _args(arguments), target = args[0] || {}; for (i = 1, len = args.length; i < len; i++) { if ((arg = args[i]) != null) { for (prop in arg) { if (_hasOwn.call(arg, prop)) { src = target[prop]; copy = arg[prop]; if (target !== copy && copy !== undefined) { target[prop] = copy; } } } } } return target; }; /** * Return a deep copy of the source object or array. * * @returns Object or Array * @private */ var _deepCopy = function(source) { var copy, i, len, prop; if (typeof source !== "object" || source == null) { copy = source; } else if (typeof source.length === "number") { copy = []; for (i = 0, len = source.length; i < len; i++) { if (_hasOwn.call(source, i)) { copy[i] = _deepCopy(source[i]); } } } else { copy = {}; for (prop in source) { if (_hasOwn.call(source, prop)) { copy[prop] = _deepCopy(source[prop]); } } } return copy; }; /** * Makes a shallow copy of `obj` (like `_extend`) but filters its properties based on a list of `keys` to keep. * The inverse of `_omit`, mostly. The big difference is that these properties do NOT need to be enumerable to * be kept. * * @returns A new filtered object. * @private */ var _pick = function(obj, keys) { var newObj = {}; for (var i = 0, len = keys.length; i < len; i++) { if (keys[i] in obj) { newObj[keys[i]] = obj[keys[i]]; } } return newObj; }; /** * Makes a shallow copy of `obj` (like `_extend`) but filters its properties based on a list of `keys` to omit. * The inverse of `_pick`. * * @returns A new filtered object. * @private */ var _omit = function(obj, keys) { var newObj = {}; for (var prop in obj) { if (keys.indexOf(prop) === -1) { newObj[prop] = obj[prop]; } } return newObj; }; /** * Remove all owned, enumerable properties from an object. * * @returns The original object without its owned, enumerable properties. * @private */ var _deleteOwnProperties = function(obj) { if (obj) { for (var prop in obj) { if (_hasOwn.call(obj, prop)) { delete obj[prop]; } } } return obj; }; /** * Determine if an element is contained within another element. * * @returns Boolean * @private */ var _containedBy = function(el, ancestorEl) { if (el && el.nodeType === 1 && el.ownerDocument && ancestorEl && (ancestorEl.nodeType === 1 && ancestorEl.ownerDocument && ancestorEl.ownerDocument === el.ownerDocument || ancestorEl.nodeType === 9 && !ancestorEl.ownerDocument && ancestorEl === el.ownerDocument)) { do { if (el === ancestorEl) { return true; } el = el.parentNode; } while (el); } return false; }; /** * Get the URL path's parent directory. * * @returns String or `undefined` * @private */ var _getDirPathOfUrl = function(url) { var dir; if (typeof url === "string" && url) { dir = url.split("#")[0].split("?")[0]; dir = url.slice(0, url.lastIndexOf("/") + 1); } return dir; }; /** * Get the current script's URL by throwing an `Error` and analyzing it. * * @returns String or `undefined` * @private */ var _getCurrentScriptUrlFromErrorStack = function(stack) { var url, matches; if (typeof stack === "string" && stack) { matches = stack.match(/^(?:|[^:@]*@|.+\)@(?=http[s]?|file)|.+?\s+(?: at |@)(?:[^:\(]+ )*[\(]?)((?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/); if (matches && matches[1]) { url = matches[1]; } else { matches = stack.match(/\)@((?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/); if (matches && matches[1]) { url = matches[1]; } } } return url; }; /** * Get the current script's URL by throwing an `Error` and analyzing it. * * @returns String or `undefined` * @private */ var _getCurrentScriptUrlFromError = function() { var url, err; try { throw new _Error(); } catch (e) { err = e; } if (err) { url = err.sourceURL || err.fileName || _getCurrentScriptUrlFromErrorStack(err.stack); } return url; }; /** * Get the current script's URL. * * @returns String or `undefined` * @private */ var _getCurrentScriptUrl = function() { var jsPath, scripts, i; if (_document.currentScript && (jsPath = _document.currentScript.src)) { return jsPath; } scripts = _document.getElementsByTagName("script"); if (scripts.length === 1) { return scripts[0].src || undefined; } if ("readyState" in scripts[0]) { for (i = scripts.length; i--; ) { if (scripts[i].readyState === "interactive" && (jsPath = scripts[i].src)) { return jsPath; } } } if (_document.readyState === "loading" && (jsPath = scripts[scripts.length - 1].src)) { return jsPath; } if (jsPath = _getCurrentScriptUrlFromError()) { return jsPath; } return undefined; }; /** * Get the unanimous parent directory of ALL script tags. * If any script tags are either (a) inline or (b) from differing parent * directories, this method must return `undefined`. * * @returns String or `undefined` * @private */ var _getUnanimousScriptParentDir = function() { var i, jsDir, jsPath, scripts = _document.getElementsByTagName("script"); for (i = scripts.length; i--; ) { if (!(jsPath = scripts[i].src)) { jsDir = null; break; } jsPath = _getDirPathOfUrl(jsPath); if (jsDir == null) { jsDir = jsPath; } else if (jsDir !== jsPath) { jsDir = null; break; } } return jsDir || undefined; }; /** * Get the presumed location of the "ZeroClipboard.swf" file, based on the location * of the executing JavaScript file (e.g. "ZeroClipboard.js", etc.). * * @returns String * @private */ var _getDefaultSwfPath = function() { var jsDir = _getDirPathOfUrl(_getCurrentScriptUrl()) || _getUnanimousScriptParentDir() || ""; return jsDir + "ZeroClipboard.swf"; }; /** * Keep track of the state of the Flash object. * @private */ var _flashState = { bridge: null, version: "0.0.0", pluginType: "unknown", disabled: null, outdated: null, unavailable: null, deactivated: null, overdue: null, ready: null }; /** * The minimum Flash Player version required to use ZeroClipboard completely. * @readonly * @private */ var _minimumFlashVersion = "11.0.0"; /** * Keep track of all event listener registrations. * @private */ var _handlers = {}; /** * Keep track of the currently activated element. * @private */ var _currentElement; /** * Keep track of the element that was activated when a `copy` process started. * @private */ var _copyTarget; /** * Keep track of data for the pending clipboard transaction. * @private */ var _clipData = {}; /** * Keep track of data formats for the pending clipboard transaction. * @private */ var _clipDataFormatMap = null; /** * The `message` store for events * @private */ var _eventMessages = { ready: "Flash communication is established", error: { "flash-disabled": "Flash is disabled or not installed", "flash-outdated": "Flash is too outdated to support ZeroClipboard", "flash-unavailable": "Flash is unable to communicate bidirectionally with JavaScript", "flash-deactivated": "Flash is too outdated for your browser and/or is configured as click-to-activate", "flash-overdue": "Flash communication was established but NOT within the acceptable time limit" } }; /** * ZeroClipboard configuration defaults for the Core module. * @private */ var _globalConfig = { swfPath: _getDefaultSwfPath(), trustedDomains: window.location.host ? [ window.location.host ] : [], cacheBust: true, forceEnhancedClipboard: false, flashLoadTimeout: 3e4, autoActivate: true, bubbleEvents: true, containerId: "global-zeroclipboard-html-bridge", containerClass: "global-zeroclipboard-container", swfObjectId: "global-zeroclipboard-flash-bridge", hoverClass: "zeroclipboard-is-hover", activeClass: "zeroclipboard-is-active", forceHandCursor: false, title: null, zIndex: 999999999 }; /** * The underlying implementation of `ZeroClipboard.config`. * @private */ var _config = function(options) { if (typeof options === "object" && options !== null) { for (var prop in options) { if (_hasOwn.call(options, prop)) { if (/^(?:forceHandCursor|title|zIndex|bubbleEvents)$/.test(prop)) { _globalConfig[prop] = options[prop]; } else if (_flashState.bridge == null) { if (prop === "containerId" || prop === "swfObjectId") { if (_isValidHtml4Id(options[prop])) { _globalConfig[prop] = options[prop]; } else { throw new Error("The specified `" + prop + "` value is not valid as an HTML4 Element ID"); } } else { _globalConfig[prop] = options[prop]; } } } } } if (typeof options === "string" && options) { if (_hasOwn.call(_globalConfig, options)) { return _globalConfig[options]; } return; } return _deepCopy(_globalConfig); }; /** * The underlying implementation of `ZeroClipboard.state`. * @private */ var _state = function() { return { browser: _pick(_navigator, [ "userAgent", "platform", "appName" ]), flash: _omit(_flashState, [ "bridge" ]), zeroclipboard: { version: ZeroClipboard.version, config: ZeroClipboard.config() } }; }; /** * The underlying implementation of `ZeroClipboard.isFlashUnusable`. * @private */ var _isFlashUnusable = function() { return !!(_flashState.disabled || _flashState.outdated || _flashState.unavailable || _flashState.deactivated); }; /** * The underlying implementation of `ZeroClipboard.on`. * @private */ var _on = function(eventType, listener) { var i, len, events, added = {}; if (typeof eventType === "string" && eventType) { events = eventType.toLowerCase().split(/\s+/); } else if (typeof eventType === "object" && eventType && typeof listener === "undefined") { for (i in eventType) { if (_hasOwn.call(eventType, i) && typeof i === "string" && i && typeof eventType[i] === "function") { ZeroClipboard.on(i, eventType[i]); } } } if (events && events.length) { for (i = 0, len = events.length; i < len; i++) { eventType = events[i].replace(/^on/, ""); added[eventType] = true; if (!_handlers[eventType]) { _handlers[eventType] = []; } _handlers[eventType].push(listener); } if (added.ready && _flashState.ready) { ZeroClipboard.emit({ type: "ready" }); } if (added.error) { var errorTypes = [ "disabled", "outdated", "unavailable", "deactivated", "overdue" ]; for (i = 0, len = errorTypes.length; i < len; i++) { if (_flashState[errorTypes[i]] === true) { ZeroClipboard.emit({ type: "error", name: "flash-" + errorTypes[i] }); break; } } } } return ZeroClipboard; }; /** * The underlying implementation of `ZeroClipboard.off`. * @private */ var _off = function(eventType, listener) { var i, len, foundIndex, events, perEventHandlers; if (arguments.length === 0) { events = _keys(_handlers); } else if (typeof eventType === "string" && eventType) { events = eventType.split(/\s+/); } else if (typeof eventType === "object" && eventType && typeof listener === "undefined") { for (i in eventType) { if (_hasOwn.call(eventType, i) && typeof i === "string" && i && typeof eventType[i] === "function") { ZeroClipboard.off(i, eventType[i]); } } } if (events && events.length) { for (i = 0, len = events.length; i < len; i++) { eventType = events[i].toLowerCase().replace(/^on/, ""); perEventHandlers = _handlers[eventType]; if (perEventHandlers && perEventHandlers.length) { if (listener) { foundIndex = perEventHandlers.indexOf(listener); while (foundIndex !== -1) { perEventHandlers.splice(foundIndex, 1); foundIndex = perEventHandlers.indexOf(listener, foundIndex); } } else { perEventHandlers.length = 0; } } } } return ZeroClipboard; }; /** * The underlying implementation of `ZeroClipboard.handlers`. * @private */ var _listeners = function(eventType) { var copy; if (typeof eventType === "string" && eventType) { copy = _deepCopy(_handlers[eventType]) || null; } else { copy = _deepCopy(_handlers); } return copy; }; /** * The underlying implementation of `ZeroClipboard.emit`. * @private */ var _emit = function(event) { var eventCopy, returnVal, tmp; event = _createEvent(event); if (!event) { return; } if (_preprocessEvent(event)) { return; } if (event.type === "ready" && _flashState.overdue === true) { return ZeroClipboard.emit({ type: "error", name: "flash-overdue" }); } eventCopy = _extend({}, event); _dispatchCallbacks.call(this, eventCopy); if (event.type === "copy") { tmp = _mapClipDataToFlash(_clipData); returnVal = tmp.data; _clipDataFormatMap = tmp.formatMap; } return returnVal; }; /** * The underlying implementation of `ZeroClipboard.create`. * @private */ var _create = function() { if (typeof _flashState.ready !== "boolean") { _flashState.ready = false; } if (!ZeroClipboard.isFlashUnusable() && _flashState.bridge === null) { var maxWait = _globalConfig.flashLoadTimeout; if (typeof maxWait === "number" && maxWait >= 0) { _setTimeout(function() { if (typeof _flashState.deactivated !== "boolean") { _flashState.deactivated = true; } if (_flashState.deactivated === true) { ZeroClipboard.emit({ type: "error", name: "flash-deactivated" }); } }, maxWait); } _flashState.overdue = false; _embedSwf(); } }; /** * The underlying implementation of `ZeroClipboard.destroy`. * @private */ var _destroy = function() { ZeroClipboard.clearData(); ZeroClipboard.blur(); ZeroClipboard.emit("destroy"); _unembedSwf(); ZeroClipboard.off(); }; /** * The underlying implementation of `ZeroClipboard.setData`. * @private */ var _setData = function(format, data) { var dataObj; if (typeof format === "object" && format && typeof data === "undefined") { dataObj = format; ZeroClipboard.clearData(); } else if (typeof format === "string" && format) { dataObj = {}; dataObj[format] = data; } else { return; } for (var dataFormat in dataObj) { if (typeof dataFormat === "string" && dataFormat && _hasOwn.call(dataObj, dataFormat) && typeof dataObj[dataFormat] === "string" && dataObj[dataFormat]) { _clipData[dataFormat] = dataObj[dataFormat]; } } }; /** * The underlying implementation of `ZeroClipboard.clearData`. * @private */ var _clearData = function(format) { if (typeof format === "undefined") { _deleteOwnProperties(_clipData); _clipDataFormatMap = null; } else if (typeof format === "string" && _hasOwn.call(_clipData, format)) { delete _clipData[format]; } }; /** * The underlying implementation of `ZeroClipboard.getData`. * @private */ var _getData = function(format) { if (typeof format === "undefined") { return _deepCopy(_clipData); } else if (typeof format === "string" && _hasOwn.call(_clipData, format)) { return _clipData[format]; } }; /** * The underlying implementation of `ZeroClipboard.focus`/`ZeroClipboard.activate`. * @private */ var _focus = function(element) { if (!(element && element.nodeType === 1)) { return; } if (_currentElement) { _removeClass(_currentElement, _globalConfig.activeClass); if (_currentElement !== element) { _removeClass(_currentElement, _globalConfig.hoverClass); } } _currentElement = element; _addClass(element, _globalConfig.hoverClass); var newTitle = element.getAttribute("title") || _globalConfig.title; if (typeof newTitle === "string" && newTitle) { var htmlBridge = _getHtmlBridge(_flashState.bridge); if (htmlBridge) { htmlBridge.setAttribute("title", newTitle); } } var useHandCursor = _globalConfig.forceHandCursor === true || _getStyle(element, "cursor") === "pointer"; _setHandCursor(useHandCursor); _reposition(); }; /** * The underlying implementation of `ZeroClipboard.blur`/`ZeroClipboard.deactivate`. * @private */ var _blur = function() { var htmlBridge = _getHtmlBridge(_flashState.bridge); if (htmlBridge) { htmlBridge.removeAttribute("title"); htmlBridge.style.left = "0px"; htmlBridge.style.top = "-9999px"; htmlBridge.style.width = "1px"; htmlBridge.style.top = "1px"; } if (_currentElement) { _removeClass(_currentElement, _globalConfig.hoverClass); _removeClass(_currentElement, _globalConfig.activeClass); _currentElement = null; } }; /** * The underlying implementation of `ZeroClipboard.activeElement`. * @private */ var _activeElement = function() { return _currentElement || null; }; /** * Check if a value is a valid HTML4 `ID` or `Name` token. * @private */ var _isValidHtml4Id = function(id) { return typeof id === "string" && id && /^[A-Za-z][A-Za-z0-9_:\-\.]*$/.test(id); }; /** * Create or update an `event` object, based on the `eventType`. * @private */ var _createEvent = function(event) { var eventType; if (typeof event === "string" && event) { eventType = event; event = {}; } else if (typeof event === "object" && event && typeof event.type === "string" && event.type) { eventType = event.type; } if (!eventType) { return; } if (!event.target && /^(copy|aftercopy|_click)$/.test(eventType.toLowerCase())) { event.target = _copyTarget; } _extend(event, { type: eventType.toLowerCase(), target: event.target || _currentElement || null, relatedTarget: event.relatedTarget || null, currentTarget: _flashState && _flashState.bridge || null, timeStamp: event.timeStamp || _now() || null }); var msg = _eventMessages[event.type]; if (event.type === "error" && event.name && msg) { msg = msg[event.name]; } if (msg) { event.message = msg; } if (event.type === "ready") { _extend(event, { target: null, version: _flashState.version }); } if (event.type === "error") { if (/^flash-(disabled|outdated|unavailable|deactivated|overdue)$/.test(event.name)) { _extend(event, { target: null, minimumVersion: _minimumFlashVersion }); } if (/^flash-(outdated|unavailable|deactivated|overdue)$/.test(event.name)) { _extend(event, { version: _flashState.version }); } } if (event.type === "copy") { event.clipboardData = { setData: ZeroClipboard.setData, clearData: ZeroClipboard.clearData }; } if (event.type === "aftercopy") { event = _mapClipResultsFromFlash(event, _clipDataFormatMap); } if (event.target && !event.relatedTarget) { event.relatedTarget = _getRelatedTarget(event.target); } event = _addMouseData(event); return event; }; /** * Get a relatedTarget from the target's `data-clipboard-target` attribute * @private */ var _getRelatedTarget = function(targetEl) { var relatedTargetId = targetEl && targetEl.getAttribute && targetEl.getAttribute("data-clipboard-target"); return relatedTargetId ? _document.getElementById(relatedTargetId) : null; }; /** * Add element and position data to `MouseEvent` instances * @private */ var _addMouseData = function(event) { if (event && /^_(?:click|mouse(?:over|out|down|up|move))$/.test(event.type)) { var srcElement = event.target; var fromElement = event.type === "_mouseover" && event.relatedTarget ? event.relatedTarget : undefined; var toElement = event.type === "_mouseout" && event.relatedTarget ? event.relatedTarget : undefined; var pos = _getDOMObjectPosition(srcElement); var screenLeft = _window.screenLeft || _window.screenX || 0; var screenTop = _window.screenTop || _window.screenY || 0; var scrollLeft = _document.body.scrollLeft + _document.documentElement.scrollLeft; var scrollTop = _document.body.scrollTop + _document.documentElement.scrollTop; var pageX = pos.left + (typeof event._stageX === "number" ? event._stageX : 0); var pageY = pos.top + (typeof event._stageY === "number" ? event._stageY : 0); var clientX = pageX - scrollLeft; var clientY = pageY - scrollTop; var screenX = screenLeft + clientX; var screenY = screenTop + clientY; var moveX = typeof event.movementX === "number" ? event.movementX : 0; var moveY = typeof event.movementY === "number" ? event.movementY : 0; delete event._stageX; delete event._stageY; _extend(event, { srcElement: srcElement, fromElement: fromElement, toElement: toElement, screenX: screenX, screenY: screenY, pageX: pageX, pageY: pageY, clientX: clientX, clientY: clientY, x: clientX, y: clientY, movementX: moveX, movementY: moveY, offsetX: 0, offsetY: 0, layerX: 0, layerY: 0 }); } return event; }; /** * Determine if an event's registered handlers should be execute synchronously or asynchronously. * * @returns {boolean} * @private */ var _shouldPerformAsync = function(event) { var eventType = event && typeof event.type === "string" && event.type || ""; return !/^(?:(?:before)?copy|destroy)$/.test(eventType); }; /** * Control if a callback should be executed asynchronously or not. * * @returns `undefined` * @private */ var _dispatchCallback = function(func, context, args, async) { if (async) { _setTimeout(function() { func.apply(context, args); }, 0); } else { func.apply(context, args); } }; /** * Handle the actual dispatching of events to client instances. * * @returns `undefined` * @private */ var _dispatchCallbacks = function(event) { if (!(typeof event === "object" && event && event.type)) { return; } var async = _shouldPerformAsync(event); var wildcardTypeHandlers = _handlers["*"] || []; var specificTypeHandlers = _handlers[event.type] || []; var handlers = wildcardTypeHandlers.concat(specificTypeHandlers); if (handlers && handlers.length) { var i, len, func, context, eventCopy, originalContext = this; for (i = 0, len = handlers.length; i < len; i++) { func = handlers[i]; context = originalContext; if (typeof func === "string" && typeof _window[func] === "function") { func = _window[func]; } if (typeof func === "object" && func && typeof func.handleEvent === "function") { context = func; func = func.handleEvent; } if (typeof func === "function") { eventCopy = _extend({}, event); _dispatchCallback(func, context, [ eventCopy ], async); } } } return this; }; /** * Preprocess any special behaviors, reactions, or state changes after receiving this event. * Executes only once per event emitted, NOT once per client. * @private */ var _preprocessEvent = function(event) { var element = event.target || _currentElement || null; var sourceIsSwf = event._source === "swf"; delete event._source; var flashErrorNames = [ "flash-disabled", "flash-outdated", "flash-unavailable", "flash-deactivated", "flash-overdue" ]; switch (event.type) { case "error": if (flashErrorNames.indexOf(event.name) !== -1) { _extend(_flashState, { disabled: event.name === "flash-disabled", outdated: event.name === "flash-outdated", unavailable: event.name === "flash-unavailable", deactivated: event.name === "flash-deactivated", overdue: event.name === "flash-overdue", ready: false }); } break; case "ready": var wasDeactivated = _flashState.deactivated === true; _extend(_flashState, { disabled: false, outdated: false, unavailable: false, deactivated: false, overdue: wasDeactivated, ready: !wasDeactivated }); break; case "beforecopy": _copyTarget = element; break; case "copy": var textContent, htmlContent, targetEl = event.relatedTarget; if (!(_clipData["text/html"] || _clipData["text/plain"]) && targetEl && (htmlContent = targetEl.value || targetEl.outerHTML || targetEl.innerHTML) && (textContent = targetEl.value || targetEl.textContent || targetEl.innerText)) { event.clipboardData.clearData(); event.clipboardData.setData("text/plain", textContent); if (htmlContent !== textContent) { event.clipboardData.setData("text/html", htmlContent); } } else if (!_clipData["text/plain"] && event.target && (textContent = event.target.getAttribute("data-clipboard-text"))) { event.clipboardData.clearData(); event.clipboardData.setData("text/plain", textContent); } break; case "aftercopy": ZeroClipboard.clearData(); if (element && element !== _safeActiveElement() && element.focus) { element.focus(); } break; case "_mouseover": ZeroClipboard.focus(element); if (_globalConfig.bubbleEvents === true && sourceIsSwf) { if (element && element !== event.relatedTarget && !_containedBy(event.relatedTarget, element)) { _fireMouseEvent(_extend({}, event, { type: "mouseenter", bubbles: false, cancelable: false })); } _fireMouseEvent(_extend({}, event, { type: "mouseover" })); } break; case "_mouseout": ZeroClipboard.blur(); if (_globalConfig.bubbleEvents === true && sourceIsSwf) { if (element && element !== event.relatedTarget && !_containedBy(event.relatedTarget, element)) { _fireMouseEvent(_extend({}, event, { type: "mouseleave", bubbles: false, cancelable: false })); } _fireMouseEvent(_extend({}, event, { type: "mouseout" })); } break; case "_mousedown": _addClass(element, _globalConfig.activeClass); if (_globalConfig.bubbleEvents === true && sourceIsSwf) { _fireMouseEvent(_extend({}, event, { type: event.type.slice(1) })); } break; case "_mouseup": _removeClass(element, _globalConfig.activeClass); if (_globalConfig.bubbleEvents === true && sourceIsSwf) { _fireMouseEvent(_extend({}, event, { type: event.type.slice(1) })); } break; case "_click": _copyTarget = null; if (_globalConfig.bubbleEvents === true && sourceIsSwf) { _fireMouseEvent(_extend({}, event, { type: event.type.slice(1) })); } break; case "_mousemove": if (_globalConfig.bubbleEvents === true && sourceIsSwf) { _fireMouseEvent(_extend({}, event, { type: event.type.slice(1) })); } break; } if (/^_(?:click|mouse(?:over|out|down|up|move))$/.test(event.type)) { return true; } }; /** * Dispatch a synthetic MouseEvent. * * @returns `undefined` * @private */ var _fireMouseEvent = function(event) { if (!(event && typeof event.type === "string" && event)) { return; } var e, target = event.target || null, doc = target && target.ownerDocument || _document, defaults = { view: doc.defaultView || _window, canBubble: true, cancelable: true, detail: event.type === "click" ? 1 : 0, button: typeof event.which === "number" ? event.which - 1 : typeof event.button === "number" ? event.button : doc.createEvent ? 0 : 1 }, args = _extend(defaults, event); if (!target) { return; } if (doc.createEvent && target.dispatchEvent) { args = [ args.type, args.canBubble, args.cancelable, args.view, args.detail, args.screenX, args.screenY, args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey, args.button, args.relatedTarget ]; e = doc.createEvent("MouseEvents"); if (e.initMouseEvent) { e.initMouseEvent.apply(e, args); e._source = "js"; target.dispatchEvent(e); } } }; /** * Create the HTML bridge element to embed the Flash object into. * @private */ var _createHtmlBridge = function() { var container = _document.createElement("div"); container.id = _globalConfig.containerId; container.className = _globalConfig.containerClass; container.style.position = "absolute"; container.style.left = "0px"; container.style.top = "-9999px"; container.style.width = "1px"; container.style.height = "1px"; container.style.zIndex = "" + _getSafeZIndex(_globalConfig.zIndex); return container; }; /** * Get the HTML element container that wraps the Flash bridge object/element. * @private */ var _getHtmlBridge = function(flashBridge) { var htmlBridge = flashBridge && flashBridge.parentNode; while (htmlBridge && htmlBridge.nodeName === "OBJECT" && htmlBridge.parentNode) { htmlBridge = htmlBridge.parentNode; } return htmlBridge || null; }; /** * Create the SWF object. * * @returns The SWF object reference. * @private */ var _embedSwf = function() { var len, flashBridge = _flashState.bridge, container = _getHtmlBridge(flashBridge); if (!flashBridge) { var allowScriptAccess = _determineScriptAccess(_window.location.host, _globalConfig); var allowNetworking = allowScriptAccess === "never" ? "none" : "all"; var flashvars = _vars(_globalConfig); var swfUrl = _globalConfig.swfPath + _cacheBust(_globalConfig.swfPath, _globalConfig); container = _createHtmlBridge(); var divToBeReplaced = _document.createElement("div"); container.appendChild(divToBeReplaced); _document.body.appendChild(container); var tmpDiv = _document.createElement("div"); var oldIE = _flashState.pluginType === "activex"; tmpDiv.innerHTML = '<object id="' + _globalConfig.swfObjectId + '" name="' + _globalConfig.swfObjectId + '" ' + 'width="100%" height="100%" ' + (oldIE ? 'classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000"' : 'type="application/x-shockwave-flash" data="' + swfUrl + '"') + ">" + (oldIE ? '<param name="movie" value="' + swfUrl + '"/>' : "") + '<param name="allowScriptAccess" value="' + allowScriptAccess + '"/>' + '<param name="allowNetworking" value="' + allowNetworking + '"/>' + '<param name="menu" value="false"/>' + '<param name="wmode" value="transparent"/>' + '<param name="flashvars" value="' + flashvars + '"/>' + "</object>"; flashBridge = tmpDiv.firstChild; tmpDiv = null; _unwrap(flashBridge).ZeroClipboard = ZeroClipboard; container.replaceChild(flashBridge, divToBeReplaced); } if (!flashBridge) { flashBridge = _document[_globalConfig.swfObjectId]; if (flashBridge && (len = flashBridge.length)) { flashBridge = flashBridge[len - 1]; } if (!flashBridge && container) { flashBridge = container.firstChild; } } _flashState.bridge = flashBridge || null; return flashBridge; }; /** * Destroy the SWF object. * @private */ var _unembedSwf = function() { var flashBridge = _flashState.bridge; if (flashBridge) { var htmlBridge = _getHtmlBridge(flashBridge); if (htmlBridge) { if (_flashState.pluginType === "activex" && "readyState" in flashBridge) { flashBridge.style.display = "none"; (function removeSwfFromIE() { if (flashBridge.readyState === 4) { for (var prop in flashBridge) { if (typeof flashBridge[prop] === "function") { flashBridge[prop] = null; } } if (flashBridge.parentNode) { flashBridge.parentNode.removeChild(flashBridge); } if (htmlBridge.parentNode) { htmlBridge.parentNode.removeChild(htmlBridge); } } else { _setTimeout(removeSwfFromIE, 10); } })(); } else { if (flashBridge.parentNode) { flashBridge.parentNode.removeChild(flashBridge); } if (htmlBridge.parentNode) { htmlBridge.parentNode.removeChild(htmlBridge); } } } _flashState.ready = null; _flashState.bridge = null; _flashState.deactivated = null; } }; /** * Map the data format names of the "clipData" to Flash-friendly names. * * @returns A new transformed object. * @private */ var _mapClipDataToFlash = function(clipData) { var newClipData = {}, formatMap = {}; if (!(typeof clipData === "object" && clipData)) { return; } for (var dataFormat in clipData) { if (dataFormat && _hasOwn.call(clipData, dataFormat) && typeof clipData[dataFormat] === "string" && clipData[dataFormat]) { switch (dataFormat.toLowerCase()) { case "text/plain": case "text": case "air:text": case "flash:text": newClipData.text = clipData[dataFormat]; formatMap.text = dataFormat; break; case "text/html": case "html": case "air:html": case "flash:html": newClipData.html = clipData[dataFormat]; formatMap.html = dataFormat; break; case "application/rtf": case "text/rtf": case "rtf": case "richtext": case "air:rtf": case "flash:rtf": newClipData.rtf = clipData[dataFormat]; formatMap.rtf = dataFormat; break; default: break; } } } return { data: newClipData, formatMap: formatMap }; }; /** * Map the data format names from Flash-friendly names back to their original "clipData" names (via a format mapping). * * @returns A new transformed object. * @private */ var _mapClipResultsFromFlash = function(clipResults, formatMap) { if (!(typeof clipResults === "object" && clipResults && typeof formatMap === "object" && formatMap)) { return clipResults; } var newResults = {}; for (var prop in clipResults) { if (_hasOwn.call(clipResults, prop)) { if (prop !== "success" && prop !== "data") { newResults[prop] = clipResults[prop]; continue; } newResults[prop] = {}; var tmpHash = clipResults[prop]; for (var dataFormat in tmpHash) { if (dataFormat && _hasOwn.call(tmpHash, dataFormat) && _hasOwn.call(formatMap, dataFormat)) { newResults[prop][formatMap[dataFormat]] = tmpHash[dataFormat]; } } } } return newResults; }; /** * Will look at a path, and will create a "?noCache={time}" or "&noCache={time}" * query param string to return. Does NOT append that string to the original path. * This is useful because ExternalInterface often breaks when a Flash SWF is cached. * * @returns The `noCache` query param with necessary "?"/"&" prefix. * @private */ var _cacheBust = function(path, options) { var cacheBust = options == null || options && options.cacheBust === true; if (cacheBust) { return (path.indexOf("?") === -1 ? "?" : "&") + "noCache=" + _now(); } else { return ""; } }; /** * Creates a query string for the FlashVars param. * Does NOT include the cache-busting query param. * * @returns FlashVars query string * @private */ var _vars = function(options) { var i, len, domain, domains, str = "", trustedOriginsExpanded = []; if (options.trustedDomains) { if (typeof options.trustedDomains === "string") { domains = [ options.trustedDomains ]; } else if (typeof options.trustedDomains === "object" && "length" in options.trustedDomains) { domains = options.trustedDomains; } } if (domains && domains.length) { for (i = 0, len = domains.length; i < len; i++) { if (_hasOwn.call(domains, i) && domains[i] && typeof domains[i] === "string") { domain = _extractDomain(domains[i]); if (!domain) { continue; } if (domain === "*") { trustedOriginsExpanded.length = 0; trustedOriginsExpanded.push(domain); break; } trustedOriginsExpanded.push.apply(trustedOriginsExpanded, [ domain, "//" + domain, _window.location.protocol + "//" + domain ]); } } } if (trustedOriginsExpanded.length) { str += "trustedOrigins=" + _encodeURIComponent(trustedOriginsExpanded.join(",")); } if (options.forceEnhancedClipboard === true) { str += (str ? "&" : "") + "forceEnhancedClipboard=true"; } if (typeof options.swfObjectId === "string" && options.swfObjectId) { str += (str ? "&" : "") + "swfObjectId=" + _encodeURIComponent(options.swfObjectId); } return str; }; /** * Extract the domain (e.g. "github.com") from an origin (e.g. "https://github.com") or * URL (e.g. "https://github.com/zeroclipboard/zeroclipboard/"). * * @returns the domain * @private */ var _extractDomain = function(originOrUrl) { if (originOrUrl == null || originOrUrl === "") { return null; } originOrUrl = originOrUrl.replace(/^\s+|\s+$/g, ""); if (originOrUrl === "") { return null; } var protocolIndex = originOrUrl.indexOf("//"); originOrUrl = protocolIndex === -1 ? originOrUrl : originOrUrl.slice(protocolIndex + 2); var pathIndex = originOrUrl.indexOf("/"); originOrUrl = pathIndex === -1 ? originOrUrl : protocolIndex === -1 || pathIndex === 0 ? null : originOrUrl.slice(0, pathIndex); if (originOrUrl && originOrUrl.slice(-4).toLowerCase() === ".swf") { return null; } return originOrUrl || null; }; /** * Set `allowScriptAccess` based on `trustedDomains` and `window.location.host` vs. `swfPath`. * * @returns The appropriate script access level. * @private */ var _determineScriptAccess = function() { var _extractAllDomains = function(origins) { var i, len, tmp, resultsArray = []; if (typeof origins === "string") { origins = [ origins ]; } if (!(typeof origins === "object" && origins && typeof origins.length === "number")) { return resultsArray; } for (i = 0, len = origins.length; i < len; i++) { if (_hasOwn.call(origins, i) && (tmp = _extractDomain(origins[i]))) { if (tmp === "*") { resultsArray.length = 0; resultsArray.push("*"); break; } if (resultsArray.indexOf(tmp) === -1) { resultsArray.push(tmp); } } } return resultsArray; }; return function(currentDomain, configOptions) { var swfDomain = _extractDomain(configOptions.swfPath); if (swfDomain === null) { swfDomain = currentDomain; } var trustedDomains = _extractAllDomains(configOptions.trustedDomains); var len = trustedDomains.length; if (len > 0) { if (len === 1 && trustedDomains[0] === "*") { return "always"; } if (trustedDomains.indexOf(currentDomain) !== -1) { if (len === 1 && currentDomain === swfDomain) { return "sameDomain"; } return "always"; } } return "never"; }; }(); /** * Get the currently active/focused DOM element. * * @returns the currently active/focused element, or `null` * @private */ var _safeActiveElement = function() { try { return _document.activeElement; } catch (err) { return null; } }; /** * Add a class to an element, if it doesn't already have it. * * @returns The element, with its new class added. * @private */ var _addClass = function(element, value) { if (!element || element.nodeType !== 1) { return element; } if (element.classList) { if (!element.classList.contains(value)) { element.classList.add(value); } return element; } if (value && typeof value === "string") { var classNames = (value || "").split(/\s+/); if (element.nodeType === 1) { if (!element.className) { element.className = value; } else { var className = " " + element.className + " ", setClass = element.className; for (var c = 0, cl = classNames.length; c < cl; c++) { if (className.indexOf(" " + classNames[c] + " ") < 0) { setClass += " " + classNames[c]; } } element.className = setClass.replace(/^\s+|\s+$/g, ""); } } } return element; }; /** * Remove a class from an element, if it has it. * * @returns The element, with its class removed. * @private */ var _removeClass = function(element, value) { if (!element || element.nodeType !== 1) { return element; } if (element.classList) { if (element.classList.contains(value)) { element.classList.remove(value); } return element; } if (typeof value === "string" && value) { var classNames = value.split(/\s+/); if (element.nodeType === 1 && element.className) { var className = (" " + element.className + " ").replace(/[\n\t]/g, " "); for (var c = 0, cl = classNames.length; c < cl; c++) { className = className.replace(" " + classNames[c] + " ", " "); } element.className = className.replace(/^\s+|\s+$/g, ""); } } return element; }; /** * Attempt to interpret the element's CSS styling. If `prop` is `"cursor"`, * then we assume that it should be a hand ("pointer") cursor if the element * is an anchor element ("a" tag). * * @returns The computed style property. * @private */ var _getStyle = function(el, prop) { var value = _window.getComputedStyle(el, null).getPropertyValue(prop); if (prop === "cursor") { if (!value || value === "auto") { if (el.nodeName === "A") { return "pointer"; } } } return value; }; /** * Get the zoom factor of the browser. Always returns `1.0`, except at * non-default zoom levels in IE<8 and some older versions of WebKit. * * @returns Floating unit percentage of the zoom factor (e.g. 150% = `1.5`). * @private */ var _getZoomFactor = function() { var rect, physicalWidth, logicalWidth, zoomFactor = 1; if (typeof _document.body.getBoundingClientRect === "function") { rect = _document.body.getBoundingClientRect(); physicalWidth = rect.right - rect.left; logicalWidth = _document.body.offsetWidth; zoomFactor = _round(physicalWidth / logicalWidth * 100) / 100; } return zoomFactor; }; /** * Get the DOM positioning info of an element. * * @returns Object containing the element's position, width, and height. * @private */ var _getDOMObjectPosition = function(obj) { var info = { left: 0, top: 0, width: 0, height: 0 }; if (obj.getBoundingClientRect) { var rect = obj.getBoundingClientRect(); var pageXOffset, pageYOffset, zoomFactor; if ("pageXOffset" in _window && "pageYOffset" in _window) { pageXOffset = _window.pageXOffset; pageYOffset = _window.pageYOffset; } else { zoomFactor = _getZoomFactor(); pageXOffset = _round(_document.documentElement.scrollLeft / zoomFactor); pageYOffset = _round(_document.documentElement.scrollTop / zoomFactor); } var leftBorderWidth = _document.documentElement.clientLeft || 0; var topBorderWidth = _document.documentElement.clientTop || 0; info.left = rect.left + pageXOffset - leftBorderWidth; info.top = rect.top + pageYOffset - topBorderWidth; info.width = "width" in rect ? rect.width : rect.right - rect.left; info.height = "height" in rect ? rect.height : rect.bottom - rect.top; } return info; }; /** * Reposition the Flash object to cover the currently activated element. * * @returns `undefined` * @private */ var _reposition = function() { var htmlBridge; if (_currentElement && (htmlBridge = _getHtmlBridge(_flashState.bridge))) { var pos = _getDOMObjectPosition(_currentElement); _extend(htmlBridge.style, { width: pos.width + "px", height: pos.height + "px", top: pos.top + "px", left: pos.left + "px", zIndex: "" + _getSafeZIndex(_globalConfig.zIndex) }); } }; /** * Sends a signal to the Flash object to display the hand cursor if `true`. * * @returns `undefined` * @private */ var _setHandCursor = function(enabled) { if (_flashState.ready === true) { if (_flashState.bridge && typeof _flashState.bridge.setHandCursor === "function") { _flashState.bridge.setHandCursor(enabled); } else { _flashState.ready = false; } } }; /** * Get a safe value for `zIndex` * * @returns an integer, or "auto" * @private */ var _getSafeZIndex = function(val) { if (/^(?:auto|inherit)$/.test(val)) { return val; } var zIndex; if (typeof val === "number" && !_isNaN(val)) { zIndex = val; } else if (typeof val === "string") { zIndex = _getSafeZIndex(_parseInt(val, 10)); } return typeof zIndex === "number" ? zIndex : "auto"; }; /** * Detect the Flash Player status, version, and plugin type. * * @see {@link https://code.google.com/p/doctype-mirror/wiki/ArticleDetectFlash#The_code} * @see {@link http://stackoverflow.com/questions/12866060/detecting-pepper-ppapi-flash-with-javascript} * * @returns `undefined` * @private */ var _detectFlashSupport = function(ActiveXObject) { var plugin, ax, mimeType, hasFlash = false, isActiveX = false, isPPAPI = false, flashVersion = ""; /** * Derived from Apple's suggested sniffer. * @param {String} desc e.g. "Shockwave Flash 7.0 r61" * @returns {String} "7.0.61" * @private */ function parseFlashVersion(desc) { var matches = desc.match(/[\d]+/g); matches.length = 3; return matches.join("."); } function isPepperFlash(flashPlayerFileName) { return !!flashPlayerFileName && (flashPlayerFileName = flashPlayerFileName.toLowerCase()) && (/^(pepflashplayer\.dll|libpepflashplayer\.so|pepperflashplayer\.plugin)$/.test(flashPlayerFileName) || flashPlayerFileName.slice(-13) === "chrome.plugin"); } function inspectPlugin(plugin) { if (plugin) { hasFlash = true; if (plugin.version) { flashVersion = parseFlashVersion(plugin.version); } if (!flashVersion && plugin.description) { flashVersion = parseFlashVersion(plugin.description); } if (plugin.filename) { isPPAPI = isPepperFlash(plugin.filename); } } } if (_navigator.plugins && _navigator.plugins.length) { plugin = _navigator.plugins["Shockwave Flash"]; inspectPlugin(plugin); if (_navigator.plugins["Shockwave Flash 2.0"]) { hasFlash = true; flashVersion = "2.0.0.11"; } } else if (_navigator.mimeTypes && _navigator.mimeTypes.length) { mimeType = _navigator.mimeTypes["application/x-shockwave-flash"]; plugin = mimeType && mimeType.enabledPlugin; inspectPlugin(plugin); } else if (typeof ActiveXObject !== "undefined") { isActiveX = true; try { ax = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.7"); hasFlash = true; flashVersion = parseFlashVersion(ax.GetVariable("$version")); } catch (e1) { try { ax = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.6"); hasFlash = true; flashVersion = "6.0.21"; } catch (e2) { try { ax = new ActiveXObject("ShockwaveFlash.ShockwaveFlash"); hasFlash = true; flashVersion = parseFlashVersion(ax.GetVariable("$version")); } catch (e3) { isActiveX = false; } } } } _flashState.disabled = hasFlash !== true; _flashState.outdated = flashVersion && _parseFloat(flashVersion) < _parseFloat(_minimumFlashVersion); _flashState.version = flashVersion || "0.0.0"; _flashState.pluginType = isPPAPI ? "pepper" : isActiveX ? "activex" : hasFlash ? "netscape" : "unknown"; }; /** * Invoke the Flash detection algorithms immediately upon inclusion so we're not waiting later. */ _detectFlashSupport(_ActiveXObject); /** * A shell constructor for `ZeroClipboard` client instances. * * @constructor */ var ZeroClipboard = function() { if (!(this instanceof ZeroClipboard)) { return new ZeroClipboard(); } if (typeof ZeroClipboard._createClient === "function") { ZeroClipboard._createClient.apply(this, _args(arguments)); } }; /** * The ZeroClipboard library's version number. * * @static * @readonly * @property {string} */ _defineProperty(ZeroClipboard, "version", { value: "2.1.6", writable: false, configurable: true, enumerable: true }); /** * Update or get a copy of the ZeroClipboard global configuration. * Returns a copy of the current/updated configuration. * * @returns Object * @static */ ZeroClipboard.config = function() { return _config.apply(this, _args(arguments)); }; /** * Diagnostic method that describes the state of the browser, Flash Player, and ZeroClipboard. * * @returns Object * @static */ ZeroClipboard.state = function() { return _state.apply(this, _args(arguments)); }; /** * Check if Flash is unusable for any reason: disabled, outdated, deactivated, etc. * * @returns Boolean * @static */ ZeroClipboard.isFlashUnusable = function() { return _isFlashUnusable.apply(this, _args(arguments)); }; /** * Register an event listener. * * @returns `ZeroClipboard` * @static */ ZeroClipboard.on = function() { return _on.apply(this, _args(arguments)); }; /** * Unregister an event listener. * If no `listener` function/object is provided, it will unregister all listeners for the provided `eventType`. * If no `eventType` is provided, it will unregister all listeners for every event type. * * @returns `ZeroClipboard` * @static */ ZeroClipboard.off = function() { return _off.apply(this, _args(arguments)); }; /** * Retrieve event listeners for an `eventType`. * If no `eventType` is provided, it will retrieve all listeners for every event type. * * @returns array of listeners for the `eventType`; if no `eventType`, then a map/hash object of listeners for all event types; or `null` */ ZeroClipboard.handlers = function() { return _listeners.apply(this, _args(arguments)); }; /** * Event emission receiver from the Flash object, forwarding to any registered JavaScript event listeners. * * @returns For the "copy" event, returns the Flash-friendly "clipData" object; otherwise `undefined`. * @static */ ZeroClipboard.emit = function() { return _emit.apply(this, _args(arguments)); }; /** * Create and embed the Flash object. * * @returns The Flash object * @static */ ZeroClipboard.create = function() { return _create.apply(this, _args(arguments)); }; /** * Self-destruct and clean up everything, including the embedded Flash object. * * @returns `undefined` * @static */ ZeroClipboard.destroy = function() { return _destroy.apply(this, _args(arguments)); }; /** * Set the pending data for clipboard injection. * * @returns `undefined` * @static */ ZeroClipboard.setData = function() { return _setData.apply(this, _args(arguments)); }; /** * Clear the pending data for clipboard injection. * If no `format` is provided, all pending data formats will be cleared. * * @returns `undefined` * @static */ ZeroClipboard.clearData = function() { return _clearData.apply(this, _args(arguments)); }; /** * Get a copy of the pending data for clipboard injection. * If no `format` is provided, a copy of ALL pending data formats will be returned. * * @returns `String` or `Object` * @static */ ZeroClipboard.getData = function() { return _getData.apply(this, _args(arguments)); }; /** * Sets the current HTML object that the Flash object should overlay. This will put the global * Flash object on top of the current element; depending on the setup, this may also set the * pending clipboard text data as well as the Flash object's wrapping element's title attribute * based on the underlying HTML element and ZeroClipboard configuration. * * @returns `undefined` * @static */ ZeroClipboard.focus = ZeroClipboard.activate = function() { return _focus.apply(this, _args(arguments)); }; /** * Un-overlays the Flash object. This will put the global Flash object off-screen; depending on * the setup, this may also unset the Flash object's wrapping element's title attribute based on * the underlying HTML element and ZeroClipboard configuration. * * @returns `undefined` * @static */ ZeroClipboard.blur = ZeroClipboard.deactivate = function() { return _blur.apply(this, _args(arguments)); }; /** * Returns the currently focused/"activated" HTML element that the Flash object is wrapping. * * @returns `HTMLElement` or `null` * @static */ ZeroClipboard.activeElement = function() { return _activeElement.apply(this, _args(arguments)); }; /** * Keep track of the ZeroClipboard client instance counter. */ var _clientIdCounter = 0; /** * Keep track of the state of the client instances. * * Entry structure: * _clientMeta[client.id] = { * instance: client, * elements: [], * handlers: {} * }; */ var _clientMeta = {}; /** * Keep track of the ZeroClipboard clipped elements counter. */ var _elementIdCounter = 0; /** * Keep track of the state of the clipped element relationships to clients. * * Entry structure: * _elementMeta[element.zcClippingId] = [client1.id, client2.id]; */ var _elementMeta = {}; /** * Keep track of the state of the mouse event handlers for clipped elements. * * Entry structure: * _mouseHandlers[element.zcClippingId] = { * mouseover: function(event) {}, * mouseout: function(event) {}, * mouseenter: function(event) {}, * mouseleave: function(event) {}, * mousemove: function(event) {} * }; */ var _mouseHandlers = {}; /** * Extending the ZeroClipboard configuration defaults for the Client module. */ _extend(_globalConfig, { autoActivate: true }); /** * The real constructor for `ZeroClipboard` client instances. * @private */ var _clientConstructor = function(elements) { var client = this; client.id = "" + _clientIdCounter++; _clientMeta[client.id] = { instance: client, elements: [], handlers: {} }; if (elements) { client.clip(elements); } ZeroClipboard.on("*", function(event) { return client.emit(event); }); ZeroClipboard.on("destroy", function() { client.destroy(); }); ZeroClipboard.create(); }; /** * The underlying implementation of `ZeroClipboard.Client.prototype.on`. * @private */ var _clientOn = function(eventType, listener) { var i, len, events, added = {}, handlers = _clientMeta[this.id] && _clientMeta[this.id].handlers; if (typeof eventType === "string" && eventType) { events = eventType.toLowerCase().split(/\s+/); } else if (typeof eventType === "object" && eventType && typeof listener === "undefined") { for (i in eventType) { if (_hasOwn.call(eventType, i) && typeof i === "string" && i && typeof eventType[i] === "function") { this.on(i, eventType[i]); } } } if (events && events.length) { for (i = 0, len = events.length; i < len; i++) { eventType = events[i].replace(/^on/, ""); added[eventType] = true; if (!handlers[eventType]) { handlers[eventType] = []; } handlers[eventType].push(listener); } if (added.ready && _flashState.ready) { this.emit({ type: "ready", client: this }); } if (added.error) { var errorTypes = [ "disabled", "outdated", "unavailable", "deactivated", "overdue" ]; for (i = 0, len = errorTypes.length; i < len; i++) { if (_flashState[errorTypes[i]]) { this.emit({ type: "error", name: "flash-" + errorTypes[i], client: this }); break; } } } } return this; }; /** * The underlying implementation of `ZeroClipboard.Client.prototype.off`. * @private */ var _clientOff = function(eventType, listener) { var i, len, foundIndex, events, perEventHandlers, handlers = _clientMeta[this.id] && _clientMeta[this.id].handlers; if (arguments.length === 0) { events = _keys(handlers); } else if (typeof eventType === "string" && eventType) { events = eventType.split(/\s+/); } else if (typeof eventType === "object" && eventType && typeof listener === "undefined") { for (i in eventType) { if (_hasOwn.call(eventType, i) && typeof i === "string" && i && typeof eventType[i] === "function") { this.off(i, eventType[i]); } } } if (events && events.length) { for (i = 0, len = events.length; i < len; i++) { eventType = events[i].toLowerCase().replace(/^on/, ""); perEventHandlers = handlers[eventType]; if (perEventHandlers && perEventHandlers.length) { if (listener) { foundIndex = perEventHandlers.indexOf(listener); while (foundIndex !== -1) { perEventHandlers.splice(foundIndex, 1); foundIndex = perEventHandlers.indexOf(listener, foundIndex); } } else { perEventHandlers.length = 0; } } } } return this; }; /** * The underlying implementation of `ZeroClipboard.Client.prototype.handlers`. * @private */ var _clientListeners = function(eventType) { var copy = null, handlers = _clientMeta[this.id] && _clientMeta[this.id].handlers; if (handlers) { if (typeof eventType === "string" && eventType) { copy = handlers[eventType] ? handlers[eventType].slice(0) : []; } else { copy = _deepCopy(handlers); } } return copy; }; /** * The underlying implementation of `ZeroClipboard.Client.prototype.emit`. * @private */ var _clientEmit = function(event) { if (_clientShouldEmit.call(this, event)) { if (typeof event === "object" && event && typeof event.type === "string" && event.type) { event = _extend({}, event); } var eventCopy = _extend({}, _createEvent(event), { client: this }); _clientDispatchCallbacks.call(this, eventCopy); } return this; }; /** * The underlying implementation of `ZeroClipboard.Client.prototype.clip`. * @private */ var _clientClip = function(elements) { elements = _prepClip(elements); for (var i = 0; i < elements.length; i++) { if (_hasOwn.call(elements, i) && elements[i] && elements[i].nodeType === 1) { if (!elements[i].zcClippingId) { elements[i].zcClippingId = "zcClippingId_" + _elementIdCounter++; _elementMeta[elements[i].zcClippingId] = [ this.id ]; if (_globalConfig.autoActivate === true) { _addMouseHandlers(elements[i]); } } else if (_elementMeta[elements[i].zcClippingId].indexOf(this.id) === -1) { _elementMeta[elements[i].zcClippingId].push(this.id); } var clippedElements = _clientMeta[this.id] && _clientMeta[this.id].elements; if (clippedElements.indexOf(elements[i]) === -1) { clippedElements.push(elements[i]); } } } return this; }; /** * The underlying implementation of `ZeroClipboard.Client.prototype.unclip`. * @private */ var _clientUnclip = function(elements) { var meta = _clientMeta[this.id]; if (!meta) { return this; } var clippedElements = meta.elements; var arrayIndex; if (typeof elements === "undefined") { elements = clippedElements.slice(0); } else { elements = _prepClip(elements); } for (var i = elements.length; i--; ) { if (_hasOwn.call(elements, i) && elements[i] && elements[i].nodeType === 1) { arrayIndex = 0; while ((arrayIndex = clippedElements.indexOf(elements[i], arrayIndex)) !== -1) { clippedElements.splice(arrayIndex, 1); } var clientIds = _elementMeta[elements[i].zcClippingId]; if (clientIds) { arrayIndex = 0; while ((arrayIndex = clientIds.indexOf(this.id, arrayIndex)) !== -1) { clientIds.splice(arrayIndex, 1); } if (clientIds.length === 0) { if (_globalConfig.autoActivate === true) { _removeMouseHandlers(elements[i]); } delete elements[i].zcClippingId; } } } } return this; }; /** * The underlying implementation of `ZeroClipboard.Client.prototype.elements`. * @private */ var _clientElements = function() { var meta = _clientMeta[this.id]; return meta && meta.elements ? meta.elements.slice(0) : []; }; /** * The underlying implementation of `ZeroClipboard.Client.prototype.destroy`. * @private */ var _clientDestroy = function() { this.unclip(); this.off(); delete _clientMeta[this.id]; }; /** * Inspect an Event to see if the Client (`this`) should honor it for emission. * @private */ var _clientShouldEmit = function(event) { if (!(event && event.type)) { return false; } if (event.client && event.client !== this) { return false; } var clippedEls = _clientMeta[this.id] && _clientMeta[this.id].elements; var hasClippedEls = !!clippedEls && clippedEls.length > 0; var goodTarget = !event.target || hasClippedEls && clippedEls.indexOf(event.target) !== -1; var goodRelTarget = event.relatedTarget && hasClippedEls && clippedEls.indexOf(event.relatedTarget) !== -1; var goodClient = event.client && event.client === this; if (!(goodTarget || goodRelTarget || goodClient)) { return false; } return true; }; /** * Handle the actual dispatching of events to a client instance. * * @returns `this` * @private */ var _clientDispatchCallbacks = function(event) { if (!(typeof event === "object" && event && event.type)) { return; } var async = _shouldPerformAsync(event); var wildcardTypeHandlers = _clientMeta[this.id] && _clientMeta[this.id].handlers["*"] || []; var specificTypeHandlers = _clientMeta[this.id] && _clientMeta[this.id].handlers[event.type] || []; var handlers = wildcardTypeHandlers.concat(specificTypeHandlers); if (handlers && handlers.length) { var i, len, func, context, eventCopy, originalContext = this; for (i = 0, len = handlers.length; i < len; i++) { func = handlers[i]; context = originalContext; if (typeof func === "string" && typeof _window[func] === "function") { func = _window[func]; } if (typeof func === "object" && func && typeof func.handleEvent === "function") { context = func; func = func.handleEvent; } if (typeof func === "function") { eventCopy = _extend({}, event); _dispatchCallback(func, context, [ eventCopy ], async); } } } return this; }; /** * Prepares the elements for clipping/unclipping. * * @returns An Array of elements. * @private */ var _prepClip = function(elements) { if (typeof elements === "string") { elements = []; } return typeof elements.length !== "number" ? [ elements ] : elements; }; /** * Add a `mouseover` handler function for a clipped element. * * @returns `undefined` * @private */ var _addMouseHandlers = function(element) { if (!(element && element.nodeType === 1)) { return; } var _suppressMouseEvents = function(event) { if (!(event || (event = _window.event))) { return; } if (event._source !== "js") { event.stopImmediatePropagation(); event.preventDefault(); } delete event._source; }; var _elementMouseOver = function(event) { if (!(event || (event = _window.event))) { return; } _suppressMouseEvents(event); ZeroClipboard.focus(element); }; element.addEventListener("mouseover", _elementMouseOver, false); element.addEventListener("mouseout", _suppressMouseEvents, false); element.addEventListener("mouseenter", _suppressMouseEvents, false); element.addEventListener("mouseleave", _suppressMouseEvents, false); element.addEventListener("mousemove", _suppressMouseEvents, false); _mouseHandlers[element.zcClippingId] = { mouseover: _elementMouseOver, mouseout: _suppressMouseEvents, mouseenter: _suppressMouseEvents, mouseleave: _suppressMouseEvents, mousemove: _suppressMouseEvents }; }; /** * Remove a `mouseover` handler function for a clipped element. * * @returns `undefined` * @private */ var _removeMouseHandlers = function(element) { if (!(element && element.nodeType === 1)) { return; } var mouseHandlers = _mouseHandlers[element.zcClippingId]; if (!(typeof mouseHandlers === "object" && mouseHandlers)) { return; } var key, val, mouseEvents = [ "move", "leave", "enter", "out", "over" ]; for (var i = 0, len = mouseEvents.length; i < len; i++) { key = "mouse" + mouseEvents[i]; val = mouseHandlers[key]; if (typeof val === "function") { element.removeEventListener(key, val, false); } } delete _mouseHandlers[element.zcClippingId]; }; /** * Creates a new ZeroClipboard client instance. * Optionally, auto-`clip` an element or collection of elements. * * @constructor */ ZeroClipboard._createClient = function() { _clientConstructor.apply(this, _args(arguments)); }; /** * Register an event listener to the client. * * @returns `this` */ ZeroClipboard.prototype.on = function() { return _clientOn.apply(this, _args(arguments)); }; /** * Unregister an event handler from the client. * If no `listener` function/object is provided, it will unregister all handlers for the provided `eventType`. * If no `eventType` is provided, it will unregister all handlers for every event type. * * @returns `this` */ ZeroClipboard.prototype.off = function() { return _clientOff.apply(this, _args(arguments)); }; /** * Retrieve event listeners for an `eventType` from the client. * If no `eventType` is provided, it will retrieve all listeners for every event type. * * @returns array of listeners for the `eventType`; if no `eventType`, then a map/hash object of listeners for all event types; or `null` */ ZeroClipboard.prototype.handlers = function() { return _clientListeners.apply(this, _args(arguments)); }; /** * Event emission receiver from the Flash object for this client's registered JavaScript event listeners. * * @returns For the "copy" event, returns the Flash-friendly "clipData" object; otherwise `undefined`. */ ZeroClipboard.prototype.emit = function() { return _clientEmit.apply(this, _args(arguments)); }; /** * Register clipboard actions for new element(s) to the client. * * @returns `this` */ ZeroClipboard.prototype.clip = function() { return _clientClip.apply(this, _args(arguments)); }; /** * Unregister the clipboard actions of previously registered element(s) on the page. * If no elements are provided, ALL registered elements will be unregistered. * * @returns `this` */ ZeroClipboard.prototype.unclip = function() { return _clientUnclip.apply(this, _args(arguments)); }; /** * Get all of the elements to which this client is clipped. * * @returns array of clipped elements */ ZeroClipboard.prototype.elements = function() { return _clientElements.apply(this, _args(arguments)); }; /** * Self-destruct and clean up everything for a single client. * This will NOT destroy the embedded Flash object. * * @returns `undefined` */ ZeroClipboard.prototype.destroy = function() { return _clientDestroy.apply(this, _args(arguments)); }; /** * Stores the pending plain text to inject into the clipboard. * * @returns `this` */ ZeroClipboard.prototype.setText = function(text) { ZeroClipboard.setData("text/plain", text); return this; }; /** * Stores the pending HTML text to inject into the clipboard. * * @returns `this` */ ZeroClipboard.prototype.setHtml = function(html) { ZeroClipboard.setData("text/html", html); return this; }; /** * Stores the pending rich text (RTF) to inject into the clipboard. * * @returns `this` */ ZeroClipboard.prototype.setRichText = function(richText) { ZeroClipboard.setData("application/rtf", richText); return this; }; /** * Stores the pending data to inject into the clipboard. * * @returns `this` */ ZeroClipboard.prototype.setData = function() { ZeroClipboard.setData.apply(this, _args(arguments)); return this; }; /** * Clears the pending data to inject into the clipboard. * If no `format` is provided, all pending data formats will be cleared. * * @returns `this` */ ZeroClipboard.prototype.clearData = function() { ZeroClipboard.clearData.apply(this, _args(arguments)); return this; }; /** * Gets a copy of the pending data to inject into the clipboard. * If no `format` is provided, a copy of ALL pending data formats will be returned. * * @returns `String` or `Object` */ ZeroClipboard.prototype.getData = function() { return ZeroClipboard.getData.apply(this, _args(arguments)); }; if (typeof define === "function" && define.amd) { define(function() { return ZeroClipboard; }); } else if (typeof module === "object" && module && typeof module.exports === "object" && module.exports) { module.exports = ZeroClipboard; } else { window.ZeroClipboard = ZeroClipboard; } })(function() { return this || window; }());"
]
}